package proto_server_client.servers;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;
import proto_server_client.logger.LogType;
import proto_server_client.utils.NetworkThread;


import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

/**
 * @author Alexa Lobas
 * @apiNote 1 - recv buffer size must be > 10
 * 2 - RECEIVE_BUFFER_SIZE_MAX - buffer can grow up to max (if max > def)
 * 3 - ONLINE_SEND_QUEUE_MAX_SIZE - size of write queue waiting for available space in system buffer.
 * if number of bytes exceed this value - connection is disconnected.
 * 0 means that only system buffer is used.
 * 4 - lastClientId  autogenerated negative connection Ids
 */
public class ProtoTCPServer extends ProtoServer {
    static final int RECEIVE_BUFFER_SIZE_DEF = 2048;
    static final int RECEIVE_BUFFER_SIZE_MAX = 16384;
    static final int ONLINE_SEND_QUEUE_MAX_SIZE = 0;

    private final List<ProtoConnection> connectionList = new LinkedList<>();
    private final int mPort;

    private Selector mSelector;
    private ServerSocketChannel mServerChannel;
    private int lastClientId = -3;

    private class ProtoConnection implements ProtoServer.Connection, ProtoCmdParser.CommandReceiver, NetworkThread.SelectionHandler {
        SocketChannel channel;
        SelectionKey key;
        LinkedList<ByteBuffer> sendQueue;
        ProtoCmdParser mCmdParser;
        Object mApi;
        LogWriter mLogWriter;
        boolean mIsConnected;
        int connectionId;

        /**
         * @apiNote per connection sendQueue will be created only if system buffer is full
         * (if write cannot send all data at once) and if ONLINE_SEND_QUEUE_MAX_SIZE is > 0
         * ONLINE_SEND_QUEUE_MAX_SIZE limits total number of bytes waiting for send in this queue
         */
        ProtoConnection(SocketChannel channel) {
            this.channel = channel;
            mCmdParser = new ProtoCmdParser(this, RECEIVE_BUFFER_SIZE_DEF, RECEIVE_BUFFER_SIZE_MAX);
            sendQueue = null;
            LogFactory factory = getLogFactory();
            if (factory != null) {
                Socket socket = channel.socket();
                SocketAddress address = socket.getRemoteSocketAddress();
                mLogWriter = factory.openConnectionLog(address);
                mCmdParser.setLogger(mLogWriter);
                mLogWriter.writeLine("New TCP connection from " + address.toString());
            }

        }

        private void writeToLog(String line) {
            if (mLogWriter != null)
                mLogWriter.writeLine(line);
        }

        private boolean hasQueuedDataForSend() {
            return sendQueue != null && !sendQueue.isEmpty() && sendQueue.getFirst().remaining() > 0;
        }

        private int getSendQueueSize() {
            if (sendQueue == null || sendQueue.isEmpty())
                return 0;

            int result = 0;
            for (ByteBuffer byteBuffer : sendQueue)
                result += byteBuffer.remaining();

            return result;
        }

        private void sendQueueData() throws IOException {
            if (sendQueue != null && !sendQueue.isEmpty()) {
                while (!sendQueue.isEmpty()) {
                    ByteBuffer buffer = sendQueue.peekFirst();
                    if (buffer != null) {
                        if (buffer.remaining() > 0) {
                            writeToLog("TCP: Send queued data " + bytesToHex(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.arrayOffset() + buffer.limit()));
                            int res = channel.write(buffer);
                            writeToLog("TCP: " + res + " bytes sent");
                        }
                        if (buffer.remaining() == 0)
                            sendQueue.removeFirst();
                    }
                }
                key.interestOps(SelectionKey.OP_READ);
            }
        }

        /**
         * @apiNote hasQueuedDataForSend() - if we are not waiting for send completion, send it immediately
         * channel.write(buffer) -  we do not store result, we use buffer pointers to check it
         * if (remaining > 0) - if data wasn't sent or were partially sent - queue it to send later
         * if (queueSize == 0) - subscribe to WRITE notification
         */
        void sendData(byte[] data) {
            ByteBuffer buffer = ByteBuffer.wrap(data);
            try {
                if (!hasQueuedDataForSend())
                    channel.write(buffer);

                int remaining = buffer.remaining();
                if (remaining > 0) {
                    int queueSize = getSendQueueSize();
                    if (queueSize + remaining > ONLINE_SEND_QUEUE_MAX_SIZE)
                        throw new InvalidProtocolBufferException("Send waiting queue exceed its max size.");

                    if (sendQueue == null)
                        sendQueue = new LinkedList<>();

                    sendQueue.addLast(buffer);
                }
            } catch (IOException e) {
                writeToLog("ERROR: TCP sendData failed. " + exceptionStackTrace(e));
                closeConnection(this);
            }
        }

        @Override
        public void onCommand(int commandId, byte[] data, int offset, int len) throws IOException {
            if (mProtocolDispatcher != null) {
                CodedInputStream stream = CodedInputStream.newInstance(data, offset, len);
                Message msg = mProtocolDispatcher.parseMessage(commandId, stream);
                mProtocolDispatcher.dispatchMessage(this, commandId, msg);
                mLogWriter.writeMessage(LogType.RECEIVER, msg, commandId);
            }
        }

        private void keyReadable() {
            try {
                int bytesRead = channel.read(mCmdParser.getBuffer());
                if (bytesRead == -1) {
                    writeToLog("TCP: Connection disconnected by remote side");
                    closeConnection(this);
                    return;
                }

                int endReadBufferPosition = mCmdParser.getBuffer().position();
                String bytes = ProtoServer.bytesToHex(mCmdParser.getBuffer().array(), (endReadBufferPosition - bytesRead), endReadBufferPosition);
                mLogWriter.writeLine("TCP: Info about bytes read: { size:[" + endReadBufferPosition + "] data: [" + bytes + "] }");

                mCmdParser.parse();
                writeToLog("TCP: " + bytesRead + " bytes received");
            } catch (IOException e) {
                notifyOnError(this, e);
                closeConnection(this);
            }
        }

        private void keyWritable() {
            try {
                sendQueueData();
            } catch (IOException e) {
                notifyOnError(this, e);
                closeConnection(this);
            }
        }

        @Override
        public void keySelected(SelectionKey key) {
            if (key.isReadable())
                keyReadable();
            else if (key.isWritable())
                keyWritable();
        }

        @Override
        public void setApi(Object o) {
            mApi = o;
        }

        @Override
        public Object getApi() {
            return mApi;
        }

        @Override
        public int getId() {
            return connectionId;
        }

        @Override
        public boolean isConnected() {
            return mIsConnected;
        }

        @Override
        public ProtoServer getServer() {
            return ProtoTCPServer.this;
        }

        @Override
        public LogWriter getLogger() {
            return mLogWriter;
        }
    }

    public ProtoTCPServer(int port) {
        this.mPort = port;
    }

    protected void sendCommand(ProtoServer.Connection connection, byte[] data) {
        ProtoConnection conn = (ProtoConnection) connection;
        if (conn != null)
            conn.sendData(data);
    }

    protected void sendBroadcast(byte[] data) {
        List<ProtoConnection> listLocalCopy = new ArrayList<>(connectionList);
        ListIterator<ProtoConnection> it = listLocalCopy.listIterator();
        String logLine = "TCP Broadcast.  Data = " + bytesToHex(data, 0, data.length);
        while (it.hasNext()) {
            ProtoConnection connection = it.next();
            connection.sendData(data);
            connection.writeToLog(logLine);
        }
    }

    protected void closeConnection(ProtoServer.Connection connection) {
        closeConnection((ProtoConnection) connection);
    }

    protected NetworkThread.ProtocolHandler getProtocolHandler() {
        return mProtocolHandler;
    }

    /**
     * @apiNote ProtoConnection connection = new ProtoConnection(clientChannel);
     * after this point IO fail should not stop whole server (just disconnect client)
     */
    NetworkThread.SelectionHandler mAcceptHandler = new NetworkThread.SelectionHandler() {
        @Override
        public void keySelected(SelectionKey key) {
            if (!key.isAcceptable())
                return;

            SocketChannel clientChannel;
            try {
                clientChannel = mServerChannel.accept();
                if (clientChannel == null)
                    return;
            } catch (IOException e) {
                writeToMainLog("ERROR: TCP accept failed " + exceptionStackTrace(e));
                stopServer();
                return;
            }

            ProtoConnection connection = new ProtoConnection(clientChannel);
            connection.connectionId = lastClientId--;
            connectionList.add(connection);
            try {
                clientChannel.configureBlocking(false);
                connection.key = clientChannel.register(mSelector, SelectionKey.OP_READ, connection);
                notifyOnConnected(connection);
            } catch (IOException e) {
                writeToMainLog("ERROR: TCP connection initialization failed " + exceptionStackTrace(e));
                notifyOnError(connection, e);
                closeConnection(connection);
            }
        }
    };

    private void closeConnection(ProtoConnection connection) {
        try {
            connection.channel.close();
        } catch (IOException e) {
            connection.writeToLog("ERROR: TCP close connection. " + exceptionStackTrace(e));
            notifyOnError(connection, e);
        }

        connectionList.remove(connection);
        notifyOnDisconnected(connection);
        if (connection.mLogWriter != null) {
            connection.mLogWriter.close();
            connection.mLogWriter = null;
        }
    }

    NetworkThread.ProtocolHandler mProtocolHandler = new NetworkThread.ProtocolHandler() {
        @Override
        public void onStart(Selector selector) throws IOException {
            try {
                mSelector = selector;
                mServerChannel = ServerSocketChannel.open();
                mServerChannel.configureBlocking(false);
                mServerChannel.socket().bind(new InetSocketAddress(mPort));
                mServerChannel.register(selector, SelectionKey.OP_ACCEPT, mAcceptHandler);
                writeToMainLog("TCP Listening. port = " + mPort);
            } catch (IOException e) {
                writeToMainLog("ERROR: TCP onStart failed. " + exceptionStackTrace(e));
                throw e;
            }
        }

        @Override
        public void onStop() throws IOException {
            try {
                ProtoConnection[] connectionsToClose = new ProtoConnection[connectionList.size()];
                connectionList.toArray(connectionsToClose);
                for (ProtoConnection connection : connectionsToClose)
                    closeConnection(connection);

                if (mServerChannel != null)
                    mServerChannel.close();

                writeToMainLog("TCP channel closed");
            } catch (IOException e) {
                writeToMainLog("ERROR: TCP onStop failed. " + exceptionStackTrace(e));
                throw e;
            }
        }

        @Override
        public long getNextWakeupTime() {
            return Long.MAX_VALUE;
        }

        @Override
        public void processTimeouts() { }
    };

}
